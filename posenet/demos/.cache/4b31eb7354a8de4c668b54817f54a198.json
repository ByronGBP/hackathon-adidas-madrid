{"dependencies":[{"name":"/Users/elvingomez/3lv27/hackathons/Mad/posenet/demos/package.json","includedInParent":true,"mtime":1525707475000},{"name":"/Users/elvingomez/3lv27/hackathons/Mad/posenet/demos/.babelrc","includedInParent":true,"mtime":1525707475000},{"name":"/Users/elvingomez/3lv27/hackathons/Mad/posenet/tsconfig.json","includedInParent":true,"mtime":1525707475000},{"name":"../keypoints","loc":{"line":3,"column":26}},{"name":"./util","loc":{"line":5,"column":21}}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar keypoints_1 = require(\"../keypoints\");\nvar util_1 = require(\"./util\");\nvar util_2 = require(\"./util\");\nvar poseChain = [\n    ['nose', 'leftEye'], ['leftEye', 'leftEar'], ['nose', 'rightEye'],\n    ['rightEye', 'rightEar'], ['nose', 'leftShoulder'],\n    ['leftShoulder', 'leftElbow'], ['leftElbow', 'leftWrist'],\n    ['leftShoulder', 'leftHip'], ['leftHip', 'leftKnee'],\n    ['leftKnee', 'leftAnkle'], ['nose', 'rightShoulder'],\n    ['rightShoulder', 'rightElbow'], ['rightElbow', 'rightWrist'],\n    ['rightShoulder', 'rightHip'], ['rightHip', 'rightKnee'],\n    ['rightKnee', 'rightAnkle']\n];\nvar parentChildrenTuples = poseChain.map(function (_a) {\n    var parentJoinName = _a[0], childJoinName = _a[1];\n    return ([keypoints_1.partIds[parentJoinName], keypoints_1.partIds[childJoinName]]);\n});\nvar parentToChildEdges = parentChildrenTuples.map(function (_a) {\n    var childJointId = _a[1];\n    return childJointId;\n});\nvar childToParentEdges = parentChildrenTuples.map(function (_a) {\n    var parentJointId = _a[0];\n    return parentJointId;\n});\nfunction getDisplacement(i, point, displacements) {\n    var numEdges = displacements.shape[2] / 2;\n    return {\n        y: displacements.get(point.y, point.x, i),\n        x: displacements.get(point.y, point.x, numEdges + i)\n    };\n}\nfunction decode(point, outputStride, height, width) {\n    return {\n        y: util_1.clamp(Math.round(point.y / outputStride), 0, height - 1),\n        x: util_1.clamp(Math.round(point.x / outputStride), 0, width - 1)\n    };\n}\nfunction traverseToTargetKeypoint(edgeId, sourceKeypoint, targetKeypointId, scoresBuffer, offsets, outputStride, displacements) {\n    var _a = scoresBuffer.shape, height = _a[0], width = _a[1];\n    var sourceKeypointIndeces = decode(sourceKeypoint.position, outputStride, height, width);\n    var displacement = getDisplacement(edgeId, sourceKeypointIndeces, displacements);\n    var displacedPoint = util_2.addVectors(sourceKeypoint.position, displacement);\n    var displacedPointIndeces = decode(displacedPoint, outputStride, height, width);\n    var offsetPoint = util_1.getOffsetPoint(displacedPointIndeces.y, displacedPointIndeces.x, targetKeypointId, offsets);\n    var targetKeypoint = util_2.addVectors(displacedPoint, { x: offsetPoint.x, y: offsetPoint.y });\n    var targetKeypointIndeces = decode(targetKeypoint, outputStride, height, width);\n    var score = scoresBuffer.get(targetKeypointIndeces.y, targetKeypointIndeces.x, targetKeypointId);\n    return { position: targetKeypoint, part: keypoints_1.partNames[targetKeypointId], score: score };\n}\nfunction decodePose(root, scores, offsets, outputStride, displacementsFwd, displacementsBwd) {\n    var numParts = scores.shape[2];\n    var numEdges = parentToChildEdges.length;\n    var instanceKeypoints = new Array(numParts);\n    var rootPart = root.part, rootScore = root.score;\n    var rootPoint = util_2.getImageCoords(rootPart, outputStride, offsets);\n    instanceKeypoints[rootPart.id] = {\n        score: rootScore,\n        part: keypoints_1.partNames[rootPart.id],\n        position: rootPoint\n    };\n    for (var edge = numEdges - 1; edge >= 0; --edge) {\n        var sourceKeypointId = parentToChildEdges[edge];\n        var targetKeypointId = childToParentEdges[edge];\n        if (instanceKeypoints[sourceKeypointId] &&\n            !instanceKeypoints[targetKeypointId]) {\n            instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores, offsets, outputStride, displacementsBwd);\n        }\n    }\n    for (var edge = 0; edge < numEdges; ++edge) {\n        var sourceKeypointId = childToParentEdges[edge];\n        var targetKeypointId = parentToChildEdges[edge];\n        if (instanceKeypoints[sourceKeypointId] &&\n            !instanceKeypoints[targetKeypointId]) {\n            instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores, offsets, outputStride, displacementsFwd);\n        }\n    }\n    return instanceKeypoints;\n}\nexports.decodePose = decodePose;\n","map":{"version":3,"file":"decodePose.js","sourceRoot":"","sources":["../src/multiPose/decodePose.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {NumberTuple, partIds, partNames, StringTuple} from '../keypoints';\nimport {Keypoint, PartWithScore, TensorBuffer3D, Vector2D} from '../types';\n\nimport {clamp, getOffsetPoint} from './util';\nimport {addVectors, getImageCoords} from './util';\n\n/*\n * Define the skeleton. This defines the parent->child relationships of our\n * tree. Arbitrarily this defines the nose as the root of the tree, however\n * since we will infer the displacement for both parent->child and\n * child->parent, we can define the tree root as any node.\n */\nconst poseChain: StringTuple[] = [\n  ['nose', 'leftEye'], ['leftEye', 'leftEar'], ['nose', 'rightEye'],\n  ['rightEye', 'rightEar'], ['nose', 'leftShoulder'],\n  ['leftShoulder', 'leftElbow'], ['leftElbow', 'leftWrist'],\n  ['leftShoulder', 'leftHip'], ['leftHip', 'leftKnee'],\n  ['leftKnee', 'leftAnkle'], ['nose', 'rightShoulder'],\n  ['rightShoulder', 'rightElbow'], ['rightElbow', 'rightWrist'],\n  ['rightShoulder', 'rightHip'], ['rightHip', 'rightKnee'],\n  ['rightKnee', 'rightAnkle']\n];\n\nconst parentChildrenTuples: NumberTuple[] = poseChain.map(\n    ([parentJoinName, childJoinName]): NumberTuple =>\n        ([partIds[parentJoinName], partIds[childJoinName]]));\n\nconst parentToChildEdges: number[] =\n    parentChildrenTuples.map(([, childJointId]) => childJointId);\n\nconst childToParentEdges: number[] =\n    parentChildrenTuples.map(([\n                               parentJointId,\n                             ]) => parentJointId);\n\nfunction getDisplacement(\n    i: number, point: Vector2D, displacements: TensorBuffer3D): Vector2D {\n  const numEdges = displacements.shape[2] / 2;\n  return {\n    y: displacements.get(point.y, point.x, i),\n    x: displacements.get(point.y, point.x, numEdges + i)\n  };\n}\n\nfunction decode(\n    point: Vector2D, outputStride: number, height: number,\n    width: number): Vector2D {\n  return {\n    y: clamp(Math.round(point.y / outputStride), 0, height - 1),\n    x: clamp(Math.round(point.x / outputStride), 0, width - 1)\n  };\n}\n\n/**\n * We get a new keypoint along the `edgeId` for the pose instance, assuming\n * that the position of the `idSource` part is already known. For this, we\n * follow the displacement vector from the source to target part (stored in\n * the `i`-t channel of the displacement tensor).\n */\nfunction traverseToTargetKeypoint(\n    edgeId: number, sourceKeypoint: Keypoint, targetKeypointId: number,\n    scoresBuffer: TensorBuffer3D, offsets: TensorBuffer3D, outputStride: number,\n    displacements: TensorBuffer3D): Keypoint {\n  const [height, width] = scoresBuffer.shape;\n\n  // Nearest neighbor interpolation for the source->target displacements.\n  const sourceKeypointIndeces =\n      decode(sourceKeypoint.position, outputStride, height, width);\n\n  const displacement =\n      getDisplacement(edgeId, sourceKeypointIndeces, displacements);\n\n  const displacedPoint = addVectors(sourceKeypoint.position, displacement);\n\n  const displacedPointIndeces =\n      decode(displacedPoint, outputStride, height, width);\n\n  const offsetPoint = getOffsetPoint(\n      displacedPointIndeces.y, displacedPointIndeces.x, targetKeypointId,\n      offsets);\n\n  const targetKeypoint =\n      addVectors(displacedPoint, {x: offsetPoint.x, y: offsetPoint.y});\n\n  const targetKeypointIndeces =\n      decode(targetKeypoint, outputStride, height, width);\n\n  const score = scoresBuffer.get(\n      targetKeypointIndeces.y, targetKeypointIndeces.x, targetKeypointId);\n\n  return {position: targetKeypoint, part: partNames[targetKeypointId], score};\n}\n\n/**\n * Follows the displacement fields to decode the full pose of the object\n * instance given the position of a part that acts as root.\n *\n * @return An array of decoded keypoints and their scores for a single pose\n */\nexport function decodePose(\n    root: PartWithScore, scores: TensorBuffer3D, offsets: TensorBuffer3D,\n    outputStride: number, displacementsFwd: TensorBuffer3D,\n    displacementsBwd: TensorBuffer3D): Keypoint[] {\n  const numParts = scores.shape[2];\n  const numEdges = parentToChildEdges.length;\n\n  const instanceKeypoints: Keypoint[] = new Array(numParts);\n  // Start a new detection instance at the position of the root.\n  const {part: rootPart, score: rootScore} = root;\n  const rootPoint = getImageCoords(rootPart, outputStride, offsets);\n\n  instanceKeypoints[rootPart.id] = {\n    score: rootScore,\n    part: partNames[rootPart.id],\n    position: rootPoint\n  };\n\n  // Decode the part positions upwards in the tree, following the backward\n  // displacements.\n  for (let edge = numEdges - 1; edge >= 0; --edge) {\n    const sourceKeypointId = parentToChildEdges[edge];\n    const targetKeypointId = childToParentEdges[edge];\n    if (instanceKeypoints[sourceKeypointId] &&\n        !instanceKeypoints[targetKeypointId]) {\n      instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(\n          edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores,\n          offsets, outputStride, displacementsBwd);\n    }\n  }\n\n  // Decode the part positions downwards in the tree, following the forward\n  // displacements.\n  for (let edge = 0; edge < numEdges; ++edge) {\n    const sourceKeypointId = childToParentEdges[edge];\n    const targetKeypointId = parentToChildEdges[edge];\n    if (instanceKeypoints[sourceKeypointId] &&\n        !instanceKeypoints[targetKeypointId]) {\n      instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(\n          edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores,\n          offsets, outputStride, displacementsFwd);\n    }\n  }\n\n  return instanceKeypoints;\n}\n"]}},"hash":"9bd97b452f7651485446cd22a54ce480","cacheData":{"env":{}}}